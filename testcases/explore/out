Device data-compute-parallel = True

[30;44m=========Optimizinginging=========[0m
Begin analyzing layer input. 
The arrival time pool of dependencies on device 0 is [0]
The arrival time pool of dependencies on device 1 is [0]
The arrival time pool of dependencies on device 2 is [0]
==>>decision pool(clock time): [0, 0, 0]
Decision for layer input: executed on device 0, end time 0

Sorting criteria: device end time
Sorted branches: ['A']
Begin analyzing layer A. 
The arrival time pool of dependencies on device 0 is [1, 1]
The arrival time pool of dependencies on device 1 is [1.0, 1]
The arrival time pool of dependencies on device 2 is [1.0, 1]
==>>decision pool(clock time): [1, 1.0, 1.0]
Decision for layer A: executed on device 0, end time 1

Sorting criteria: device end time
Sorted branches: ['B', 'D']
Begin analyzing layer B. 
The arrival time pool of dependencies on device 0 is [2, 2]
The arrival time pool of dependencies on device 1 is [3.0, 1]
The arrival time pool of dependencies on device 2 is [3.0, 1]
==>>decision pool(clock time): [2, 3.0, 3.0]
Decision for layer B: executed on device 0, end time 2

Sorting criteria: device end time
Sorted branches: ['C']
Begin analyzing layer C. 
The arrival time pool of dependencies on device 0 is [3, 3]
The arrival time pool of dependencies on device 1 is [4.0, 1]
The arrival time pool of dependencies on device 2 is [4.0, 1]
==>>decision pool(clock time): [3, 4.0, 4.0]
Decision for layer C: executed on device 0, end time 3

Sorting criteria: device end time
Sorted branches: ['H']
Begin analyzing layer D. 
The arrival time pool of dependencies on device 0 is [2, 4]
The arrival time pool of dependencies on device 1 is [3.0, 1]
The arrival time pool of dependencies on device 2 is [3.0, 1]
==>>decision pool(clock time): [4, 3.0, 3.0]
Decision for layer D: executed on device 1, end time 3.0

Sorting criteria: device end time
Sorted branches: ['E', 'F']
Begin analyzing layer E. 
The arrival time pool of dependencies on device 0 is [5.0, 4]
The arrival time pool of dependencies on device 1 is [4.0, 4.0]
The arrival time pool of dependencies on device 2 is [5.0, 1]
==>>decision pool(clock time): [5.0, 4.0, 5.0]
Decision for layer E: executed on device 1, end time 4.0

Sorting criteria: device end time
Sorted branches: ['G']
Begin analyzing layer F. 
The arrival time pool of dependencies on device 0 is [5.0, 4]
The arrival time pool of dependencies on device 1 is [4.0, 5.0]
The arrival time pool of dependencies on device 2 is [5.0, 1]
==>>decision pool(clock time): [5.0, 5.0, 5.0]
Decision for layer F: executed on device 0, end time 5.0

Sorting criteria: device end time
Sorted branches: ['G']
Begin analyzing layer G. 
The arrival time pool of dependencies on device 0 is [6.0, 6.0, 6.0]
The arrival time pool of dependencies on device 1 is [5.0, 7.0, 5.0]
The arrival time pool of dependencies on device 2 is [6.0, 7.0, 1]
==>>decision pool(clock time): [6.0, 7.0, 7.0]
Decision for layer G: executed on device 0, end time 6.0

Sorting criteria: device end time
Sorted branches: ['H']
Begin analyzing layer H. 
The arrival time pool of dependencies on device 0 is [4, 7.0, 7.0]
The arrival time pool of dependencies on device 1 is [5.0, 8.0, 5.0]
The arrival time pool of dependencies on device 2 is [5.0, 8.0, 1]
==>>decision pool(clock time): [7.0, 8.0, 8.0]
Decision for layer H: executed on device 0, end time 7.0

Sorting criteria: device end time
Sorted branches: ['output']

[30;42m=========Result=========[0m
layer name      device         
input           0              
A               0              
B               0              
C               0              
H               0              
D               1              
E               1              
F               0              
G               0              
output          0              

================PRIORITIES================
layer input      has priority range (None    , 0       ]	 (finish at 0)
layer A          has priority range (750.0   , 1000.0  ]	 (finish at 1)
layer B          has priority range (0.0     , 500.0   ]	 (finish at 2)
layer C          has priority range (0.0     , 500.0   ]	 (finish at 3)
layer H          has priority range (0.0     , 1000.0  ]	 (finish at 7.0)
layer D          has priority range (750.0   , 1000.0  ]	 (finish at 3.0)
layer E          has priority range (500.0   , 750.0   ]	 (finish at 4.0)
layer F          has priority range (750.0   , 1000.0  ]	 (finish at 5.0)
layer G          has priority range (500.0   , 1000.0  ]	 (finish at 6.0)
layer output     has priority range (0       , 1000    ]	 (finish at 0)
==========================================


[30;44m=========Optimizinginging=========[0m
Begin analyzing layer input. 
The arrival time pool of dependencies on device 0 is [0]
The arrival time pool of dependencies on device 1 is [0]
The arrival time pool of dependencies on device 2 is [0]
==>>decision pool(clock time): [0, 0, 0]
Decision for layer input: executed on device 0, end time 0

Sorting criteria: priorities
Sorted branches: ['A']
Begin analyzing layer A. 
The arrival time pool of dependencies on device 0 is [1, 1]
The arrival time pool of dependencies on device 1 is [1.0, 1]
The arrival time pool of dependencies on device 2 is [1.0, 1]
==>>decision pool(clock time): [1, 1.0, 1.0]
Decision for layer A: executed on device 0, end time 1

Sorting criteria: priorities
Sorted branches: ['D', 'B']
Begin analyzing layer D. 
The arrival time pool of dependencies on device 0 is [2, 2]
The arrival time pool of dependencies on device 1 is [3.0, 1]
The arrival time pool of dependencies on device 2 is [3.0, 1]
==>>decision pool(clock time): [2, 3.0, 3.0]
Decision for layer D: executed on device 0, end time 2

Sorting criteria: priorities
Sorted branches: ['F', 'E']
Begin analyzing layer F. 
The arrival time pool of dependencies on device 0 is [3, 3]
The arrival time pool of dependencies on device 1 is [4.0, 1]
The arrival time pool of dependencies on device 2 is [4.0, 1]
==>>decision pool(clock time): [3, 4.0, 4.0]
Decision for layer F: executed on device 0, end time 3

Sorting criteria: priorities
Sorted branches: ['G']
Begin analyzing layer E. 
The arrival time pool of dependencies on device 0 is [3, 4]
The arrival time pool of dependencies on device 1 is [4.0, 1]
The arrival time pool of dependencies on device 2 is [4.0, 1]
==>>decision pool(clock time): [4, 4.0, 4.0]
Decision for layer E: executed on device 0, end time 4

Sorting criteria: priorities
Sorted branches: ['G']
Begin analyzing layer G. 
The arrival time pool of dependencies on device 0 is [5, 4, 5]
The arrival time pool of dependencies on device 1 is [6.0, 5.0, 1]
The arrival time pool of dependencies on device 2 is [6.0, 5.0, 1]
==>>decision pool(clock time): [5, 6.0, 6.0]
Decision for layer G: executed on device 0, end time 5

Sorting criteria: priorities
Sorted branches: ['H']
Begin analyzing layer B. 
The arrival time pool of dependencies on device 0 is [2, 6]
The arrival time pool of dependencies on device 1 is [3.0, 1]
The arrival time pool of dependencies on device 2 is [3.0, 1]
==>>decision pool(clock time): [6, 3.0, 3.0]
Decision for layer B: executed on device 1, end time 3.0

Sorting criteria: priorities
Sorted branches: ['C']
Begin analyzing layer C. 
The arrival time pool of dependencies on device 0 is [5.0, 6]
The arrival time pool of dependencies on device 1 is [4.0, 4.0]
The arrival time pool of dependencies on device 2 is [5.0, 1]
==>>decision pool(clock time): [6, 4.0, 5.0]
Decision for layer C: executed on device 1, end time 4.0

Sorting criteria: priorities
Sorted branches: ['H']
Begin analyzing layer H. 
The arrival time pool of dependencies on device 0 is [6.0, 6, 6]
The arrival time pool of dependencies on device 1 is [5.0, 7.0, 5.0]
The arrival time pool of dependencies on device 2 is [6.0, 7.0, 1]
==>>decision pool(clock time): [6.0, 7.0, 7.0]
Decision for layer H: executed on device 0, end time 6.0

Sorting criteria: priorities
Sorted branches: ['output']

[30;42m=========Result=========[0m
layer name      device         
input           0              
A               0              
B               1              
C               1              
H               0              
D               0              
E               0              
F               0              
G               0              
output          0              
