Device data-compute-parallel = True

[30;44m=========Optimizinginging=========[0m
Begin analyzing layer input. 
The arrival time pool of dependencies on device 0 is [0]
The arrival time pool of dependencies on device 1 is [0]
The arrival time pool of dependencies on device 2 is [0]
==>>decision pool(clock time): [0, 0, 0]
Decision for layer input: executed on device 0, end time 0

Sorting criteria: device end time
Sorted branches: ['A']
Begin analyzing layer A. 
The arrival time pool of dependencies on device 0 is [2, 2]
The arrival time pool of dependencies on device 1 is [2.0, 2]
The arrival time pool of dependencies on device 2 is [2.0, 2]
==>>decision pool(clock time): [2, 2.0, 2.0]
Decision for layer A: executed on device 0, end time 2

Sorting criteria: device end time
Sorted branches: ['B', 'D']
Begin analyzing layer B. 
The arrival time pool of dependencies on device 0 is [4, 4]
The arrival time pool of dependencies on device 1 is [5.0, 2]
The arrival time pool of dependencies on device 2 is [5.0, 2]
==>>decision pool(clock time): [4, 5.0, 5.0]
Decision for layer B: executed on device 0, end time 4

Sorting criteria: device end time
Sorted branches: ['C']
Begin analyzing layer C. 
The arrival time pool of dependencies on device 0 is [6, 6]
The arrival time pool of dependencies on device 1 is [7.0, 2]
The arrival time pool of dependencies on device 2 is [7.0, 2]
==>>decision pool(clock time): [6, 7.0, 7.0]
Decision for layer C: executed on device 0, end time 6

Sorting criteria: device end time
Sorted branches: ['H']
Begin analyzing layer D. 
The arrival time pool of dependencies on device 0 is [4, 8]
The arrival time pool of dependencies on device 1 is [5.0, 2]
The arrival time pool of dependencies on device 2 is [5.0, 2]
==>>decision pool(clock time): [8, 5.0, 5.0]
Decision for layer D: executed on device 1, end time 5.0

Sorting criteria: device end time
Sorted branches: ['E', 'F']
Begin analyzing layer E. 
The arrival time pool of dependencies on device 0 is [8.0, 8]
The arrival time pool of dependencies on device 1 is [7.0, 7.0]
The arrival time pool of dependencies on device 2 is [8.0, 2]
==>>decision pool(clock time): [8.0, 7.0, 8.0]
Decision for layer E: executed on device 1, end time 7.0

Sorting criteria: device end time
Sorted branches: ['G']
Begin analyzing layer F. 
The arrival time pool of dependencies on device 0 is [8.0, 8]
The arrival time pool of dependencies on device 1 is [7.0, 9.0]
The arrival time pool of dependencies on device 2 is [8.0, 2]
==>>decision pool(clock time): [8.0, 9.0, 8.0]
Decision for layer F: executed on device 0, end time 8.0

Sorting criteria: device end time
Sorted branches: ['G']
Begin analyzing layer G. 
The arrival time pool of dependencies on device 0 is [10.0, 10.0, 10.0]
The arrival time pool of dependencies on device 1 is [9.0, 11.0, 9.0]
The arrival time pool of dependencies on device 2 is [10.0, 11.0, 2]
==>>decision pool(clock time): [10.0, 11.0, 11.0]
Decision for layer G: executed on device 0, end time 10.0

Sorting criteria: device end time
Sorted branches: ['H']
Begin analyzing layer H. 
The arrival time pool of dependencies on device 0 is [8, 12.0, 12.0]
The arrival time pool of dependencies on device 1 is [9.0, 13.0, 9.0]
The arrival time pool of dependencies on device 2 is [9.0, 13.0, 2]
==>>decision pool(clock time): [12.0, 13.0, 13.0]
Decision for layer H: executed on device 0, end time 12.0

Sorting criteria: device end time
Sorted branches: ['output']

[30;42m=========Result=========[0m
layer name      device         
input           0              
A               0              
B               0              
C               0              
H               0              
D               1              
E               1              
F               0              
G               0              
output          0              

================PRIORITIES================
layer input      has priority range (None    , 0       ]	 (finish at 0)
layer A          has priority range (750.0   , 1000.0  ]	 (finish at 2)
layer B          has priority range (0.0     , 500.0   ]	 (finish at 4)
layer C          has priority range (0.0     , 500.0   ]	 (finish at 6)
layer H          has priority range (0.0     , 1000.0  ]	 (finish at 12.0)
layer D          has priority range (750.0   , 1000.0  ]	 (finish at 5.0)
layer E          has priority range (500.0   , 750.0   ]	 (finish at 7.0)
layer F          has priority range (750.0   , 1000.0  ]	 (finish at 8.0)
layer G          has priority range (500.0   , 1000.0  ]	 (finish at 10.0)
layer output     has priority range (0       , 1000    ]	 (finish at 0)
==========================================


[30;44m=========Optimizinginging=========[0m
Begin analyzing layer input. 
The arrival time pool of dependencies on device 0 is [0]
The arrival time pool of dependencies on device 1 is [0]
The arrival time pool of dependencies on device 2 is [0]
==>>decision pool(clock time): [0, 0, 0]
Decision for layer input: executed on device 0, end time 0

Sorting criteria: priorities
Sorted branches: ['A']
Begin analyzing layer A. 
The arrival time pool of dependencies on device 0 is [2, 2]
The arrival time pool of dependencies on device 1 is [2.0, 2]
The arrival time pool of dependencies on device 2 is [2.0, 2]
==>>decision pool(clock time): [2, 2.0, 2.0]
Decision for layer A: executed on device 0, end time 2

Sorting criteria: priorities
Sorted branches: ['D', 'B']
Begin analyzing layer D. 
The arrival time pool of dependencies on device 0 is [4, 4]
The arrival time pool of dependencies on device 1 is [5.0, 2]
The arrival time pool of dependencies on device 2 is [5.0, 2]
==>>decision pool(clock time): [4, 5.0, 5.0]
Decision for layer D: executed on device 0, end time 4

Sorting criteria: priorities
Sorted branches: ['F', 'E']
Begin analyzing layer F. 
The arrival time pool of dependencies on device 0 is [6, 6]
The arrival time pool of dependencies on device 1 is [7.0, 2]
The arrival time pool of dependencies on device 2 is [7.0, 2]
==>>decision pool(clock time): [6, 7.0, 7.0]
Decision for layer F: executed on device 0, end time 6

Sorting criteria: priorities
Sorted branches: ['G']
Begin analyzing layer E. 
The arrival time pool of dependencies on device 0 is [6, 8]
The arrival time pool of dependencies on device 1 is [7.0, 2]
The arrival time pool of dependencies on device 2 is [7.0, 2]
==>>decision pool(clock time): [8, 7.0, 7.0]
Decision for layer E: executed on device 1, end time 7.0

Sorting criteria: priorities
Sorted branches: ['G']
Begin analyzing layer G. 
The arrival time pool of dependencies on device 0 is [10.0, 8, 8]
The arrival time pool of dependencies on device 1 is [9.0, 9.0, 9.0]
The arrival time pool of dependencies on device 2 is [10.0, 9.0, 2]
==>>decision pool(clock time): [10.0, 9.0, 10.0]
Decision for layer G: executed on device 1, end time 9.0

Sorting criteria: priorities
Sorted branches: ['H']
Begin analyzing layer B. 
The arrival time pool of dependencies on device 0 is [4, 8]
The arrival time pool of dependencies on device 1 is [5.0, 11.0]
The arrival time pool of dependencies on device 2 is [5.0, 2]
==>>decision pool(clock time): [8, 11.0, 5.0]
Decision for layer B: executed on device 2, end time 5.0

Sorting criteria: priorities
Sorted branches: ['C']
Begin analyzing layer C. 
The arrival time pool of dependencies on device 0 is [8.0, 8]
The arrival time pool of dependencies on device 1 is [8.0, 11.0]
The arrival time pool of dependencies on device 2 is [7.0, 7.0]
==>>decision pool(clock time): [8.0, 11.0, 7.0]
Decision for layer C: executed on device 2, end time 7.0

Sorting criteria: priorities
Sorted branches: ['H']
Begin analyzing layer H. 
The arrival time pool of dependencies on device 0 is [10.0, 12.0, 8]
The arrival time pool of dependencies on device 1 is [10.0, 11.0, 11.0]
The arrival time pool of dependencies on device 2 is [9.0, 12.0, 9.0]
==>>decision pool(clock time): [12.0, 11.0, 12.0]
Decision for layer H: executed on device 1, end time 11.0

Sorting criteria: priorities
Sorted branches: ['output']

[30;42m=========Result=========[0m
layer name      device         
input           0              
A               0              
B               2              
C               2              
H               1              
D               0              
E               1              
F               0              
G               1              
output          1              
